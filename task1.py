from utils.loader import load_ontology, load_model
from metrics import compute_metrics

g = load_ontology("Ontologies/Cartoon/Cartoon.ttl")
model = load_model()

# Query for all subclasses (anything that is a type of something else)
qres = g.query(
    """
    SELECT ?subclass ?superclass
    WHERE {
      ?subclass a ?superclass .
    }
    """
)

response_txt = ""
referencePairs = ""

# Create a dictionary to hold the superclasses and their subclasses
superclasses = {}
superclass_lst = ""

for row in qres:
    subclass, superclass = row
    if superclass not in superclasses:
        superclasses[superclass] = set()
    superclasses[superclass].add(subclass)

# Print the superclasses and their subclasses
for superclass, subclasses in superclasses.items():   
    print(f"Superclass: {superclass}")
    referencePairs += f"Superclass: {superclass}\n"
    superclass_lst+=superclass + ","
    for subclass in subclasses:
        print(f" - Subclass: {subclass}")
        referencePairs += f" - Subclass: {subclass}\n"

from itertools import islice

# Assuming 'superclasses' is your dictionary
first_five_pairs = dict(islice(superclasses.items(), 5))

# Print the first five key-value pairs
for superclass, subclasses in first_five_pairs.items():
    response_txt += f"Superclass: {superclass}\n"
    for subclass in subclasses:
        response_txt += f" - Subclass: {subclass}\n"

intro = "Our project aims to develop a system that validates ontologies using Language Models (LMs) and publicly available Knowledge Graphs (KGs)."

prompt = intro + "For every identified superclass in the following text , generate a list of possible subclasses: "+ superclass_lst +". If there are n super classes, then there must be n lists for sub classes.For example - "+ response_txt+".However You must generate the possible subclasses for all the superclasses in the list:-"+superclass_lst
response = model.generate_content(prompt)

print("List of possible subclasses for each superclass identified by the LLM")
print(response.text)

prompt2 =  "Given the reference superclass-subclass pairs as :-" + referencePairs + ", and the superclass-subclass pairs generated by LLM as" + response.text + ". I want to generate 3 integers, where the first integer is the length of reference superclass-subclass pairs, second integer is the length of superclass-subclass pairs generated by LLM and the third integer is the number of common superclass-subclass pairs between the reference and generated pairs.Your output should be strictly in the form of 3 comma separated integers and nothing else."
response2 = model.generate_content(prompt2)

print("OUTPUT: ")
print(response2.text)

def is_valid_input(input_string):
    # Split the string by commas and remove whitespace
    parts = [part.strip() for part in input_string.split(',')]
    
    # Check if there are exactly three parts and all are integers
    return len(parts) == 3 and all(part.isdigit() for part in parts)
try:
    if is_valid_input(response2.text):
        # Split the string into a list of numbers and convert them to integers
        ref_len, pred_len, inter_len = map(int, response2.text.split(','))
        precision,recall,f1_score = compute_metrics(ref_len, pred_len, inter_len)

        print(f"Precision: {precision}")
        print(f"Recall: {recall}")
        print(f"F1 Score: {f1_score}")
    
except Exception as e:
    # Display an error message if the input is not valid
    print("LLM did not generated comma separated output of 3 integers. Please try again.")

